go语言的协程是其重要的特性，协程十分轻量级。基本上，用好协程可以办大事，比如处理高并发的连接请求、充分利用CPU多核心提升已有代码的计算速度。随着协程的增多，问题也随之而来，如果一味的增加协程的个数，而没有一个很好的管理机制，性能将很快达到瓶颈，这并不是我们想要的。所以，协程的管理是值得研究的。

这个项目就是一个对协程管理的好框架，整个框架代码量不多，但能够支持几十万的并发，得益于其协程缓冲和回收机制。协程池的实现，说起来其实都大同小异，典型的实现方法不外乎下面这几行代码：
``` go
ch := make(chan int,3)

func add2Queue(ch chan<- int){
    go func(){
        for i:=0;i < 10;i++{
            ch <- i
        }
    }
}

//three goroutine
func work(ch <-chan int){
    for j := 0; j < 3; j++{
        go func(){
            for c := range ch{
                dosomething()
            }
        }
    }
}
```
这是最基本的思想，这个思想是我自己的公司写代码时琢磨出来的，后来看了很多goroutine pool的实现，发现这个是最本质的东西。